<!DOCTYPE html>
<html>
<head>
  <title>Oakland Battle Bots '25 ‚Äì Leadership Gauntlet</title>
  <meta charset="UTF-8" />
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background: radial-gradient(circle at top, #1f2933, #020617);
      color: #f9fafb;
      margin: 0;
      padding: 20px;
    }

    h1 { margin-bottom: 5px; }
    h2 { margin-top: 20px; margin-bottom: 10px; }

    #arena {
      display: flex;
      gap: 20px;
      margin-top: 20px;
      align-items: flex-start;
      justify-content: center;
      flex-wrap: wrap;
    }

    #controls, #logPanel {
      background: rgba(15, 23, 42, 0.95);
      padding: 15px;
      border-radius: 10px;
      width: 280px;
      box-shadow: 0 0 10px rgba(15, 23, 42, 0.7);
    }

    #bots {
      flex: 1;
      min-width: 320px;
      max-width: 650px;
      background: rgba(15, 23, 42, 0.95);
      border-radius: 10px;
      padding: 10px 10px 15px;
      box-shadow: 0 0 10px rgba(15, 23, 42, 0.7);
      max-height: 480px;
      overflow-y: auto;
    }

    .bot {
      margin: 8px auto;
      padding: 8px 10px;
      background: #020617;
      border-radius: 10px;
      width: 100%;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      gap: 10px;
      transition: transform 0.15s;
      position: relative;
    }

    .botEmoji { font-size: 26px; }

    .botInfo { flex: 1; text-align: left; }

    .botName {
      font-weight: bold;
      margin-bottom: 3px;
    }

    .health {
      height: 16px;
      background: #111827;
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid #1f2937;
    }

    .bar {
      height: 100%;
      width: 100%;
      transition: width 0.3s;
    }

    .stats {
      font-size: 11px;
      margin-top: 3px;
      opacity: 0.85;
    }

    .tauntBtn {
      background: #f97316;
      border: none;
      color: #111827;
      padding: 4px 8px;
      border-radius: 999px;
      cursor: pointer;
      font-size: 11px;
      font-weight: bold;
    }

    .tauntBtn:active { transform: scale(0.95); }

    .tauntBubble {
      position: absolute;
      right: 10px;
      top: -5px;
      background: #facc15;
      color: #111827;
      padding: 3px 8px;
      border-radius: 999px;
      font-size: 11px;
      animation: floatUp 1s ease-out forwards;
      pointer-events: none;
      white-space: nowrap;
    }

    @keyframes floatUp {
      0%   { opacity: 0; transform: translateY(8px); }
      10%  { opacity: 1; }
      100% { opacity: 0; transform: translateY(-18px); }
    }

    /* Battle animations */
    .attacking { animation: attackShake 0.25s; }

    @keyframes attackShake {
      0%   { transform: translateX(0); }
      25%  { transform: translateX(-3px); }
      50%  { transform: translateX(3px); }
      75%  { transform: translateX(-2px); }
      100% { transform: translateX(0); }
    }

    .hit { animation: hitFlash 0.3s; }

    @keyframes hitFlash {
      0%   { background-color: #7f1d1d; }
      100% { background-color: #020617; }
    }

    #logPanel {
      text-align: left;
      max-height: 480px;
      overflow-y: auto;
      font-size: 13px;
    }

    #log {
      max-height: 380px;
      overflow-y: auto;
      padding-right: 5px;
    }

    .logLine { margin-bottom: 4px; }

    #countdown {
      font-size: 18px;
      font-weight: bold;
      margin-top: 10px;
      min-height: 24px;
    }

    input, select {
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #4b5563;
      background: #020617;
      color: #f9fafb;
      margin-bottom: 8px;
      width: 100%;
      box-sizing: border-box;
    }

    button.main {
      margin-top: 10px;
      padding: 8px 16px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
      background: linear-gradient(90deg, #22c55e, #22d3ee);
      color: #020617;
      width: 100%;
    }

    button.main:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .subtitle { font-size: 13px; opacity: 0.9; }
    .small { font-size: 11px; opacity: 0.7; }

    /* Quiz section ‚Äì Kahoot-ish */
    #quizContainer {
      margin-top: 20px;
      background: #020617;
      border-radius: 18px;
      padding: 16px 18px;
      text-align: left;
      font-size: 14px;
      max-width: 760px;
      margin-left: auto;
      margin-right: auto;
      box-shadow: 0 0 20px rgba(15, 23, 42, 0.9);
      display: none;
    }

    #quizHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      background: linear-gradient(90deg, #6366f1, #ec4899);
    }

    #quizTitle {
      font-weight: bold;
      font-size: 16px;
    }

    #quizTimer {
      font-size: 18px;
      font-weight: bold;
    }

    #questionBox {
      margin-top: 6px;
      margin-bottom: 12px;
    }

    .q-text {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 12px;
    }

    /* CLICKABLE ANSWER CARDS */
    .answerOption {
      display: block;
      width: 100%;
      text-align: left;
      padding: 12px 14px;
      border-radius: 12px;
      background: #0b1120;
      border: 1px solid #374151;
      margin-bottom: 8px;
      cursor: pointer;
      line-height: 1.5;
      word-break: break-word;
      transition: transform 0.08s ease, box-shadow 0.08s ease, border-color 0.08s ease, background 0.08s ease;
      box-sizing: border-box;
    }

    .answerOption:hover {
      border-color: #60a5fa;
      background: #020617;
      transform: translateY(-1px);
      box-shadow: 0 0 10px rgba(37, 99, 235, 0.4);
    }

    .answerOption span.answerLetter {
      display: inline-block;
      width: 26px;
      height: 26px;
      border-radius: 999px;
      background: #1e293b;
      text-align: center;
      line-height: 26px;
      font-weight: bold;
      margin-right: 8px;
      font-size: 13px;
    }

    .answerOption.selected {
      border-color: #22c55e;
      background: #022c22;
      box-shadow: 0 0 12px rgba(34, 197, 94, 0.5);
    }

    #quizSummary {
      margin-top: 10px;
      font-size: 12px;
      line-height: 1.4;
      text-align: left;
      max-width: 760px;
      margin-left: auto;
      margin-right: auto;
    }

    #roleSelect {
      margin-bottom: 12px;
    }

    #roleSelect button {
      margin: 0 6px;
      padding: 6px 12px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-weight: bold;
      background: #e5e7eb;
      color: #111827;
    }

    #roleHint {
      font-size: 12px;
      opacity: 0.9;
      margin-top: 4px;
    }

    .hidden { display: none; }

    /* Squad vs GM layout differences */
    body.mode-squad #bots,
    body.mode-squad #logPanel {
      display: none;
    }

    body.mode-squad #arena {
      justify-content: center;
    }

    body.mode-squad #controls {
      width: min(820px, 100%);
    }

    body.mode-gm #controls {
      width: 280px;
    }
  </style>
</head>
<body>

  <h1>ü§ñ Team Battle Bots ‚Äì Leadership Tournament</h1>
  <div class="subtitle">
    Each breakout squad builds ONE bot from leadership questions. Then we run a 1v1 bracket until a champion remains.
  </div>

  <div id="roleSelect">
    <button onclick="selectRole('squad')">I'm a Squad</button>
    <button onclick="selectRole('gm')">I'm Game Master</button>
    <div id="roleHint">‚ö†Ô∏è Students click "I'm a Squad". Only you click "I'm Game Master".</div>
  </div>

  <div id="arena" class="hidden">
    <div id="controls">
      <!-- Squad Mode Panel -->
      <div id="squadPanel" class="hidden">
        <h2>Squad Bot Setup</h2>
        <input id="botName" placeholder="Squad bot name (e.g. Justice League)" maxlength="20">
        <select id="botEmoji">
          <option value="ü§ñ">ü§ñ Robot</option>
          <option value="üêâ">üêâ Dragon</option>
          <option value="üíÄ">üíÄ Skull</option>
          <option value="ü¶à">ü¶à Shark</option>
          <option value="üêê">üêê GOAT</option>
          <option value="üî•">üî• Fire</option>
          <option value="‚ö°">‚ö° Lightning</option>
        </select>
        <button class="main" id="startQuizBtn" onclick="startQuiz()">Start Squad Quiz</button>

        <div id="quizContainer">
          <div id="quizHeader">
            <div id="quizTitle">Squad Quiz ‚Äì Leadership & Power (20 Questions)</div>
            <div id="quizTimer">‚è≥ 35s</div>
          </div>
          <div class="small" style="margin-bottom:8px;">
            Your squad gets ~35 seconds per question. Answer fast and loud like Kahoot.
          </div>
          <div id="questionBox"></div>
          <button class="main" onclick="submitAnswer()">Submit Answer</button>
        </div>

        <div id="quizSummary"></div>
      </div>

      <!-- Game Master Panel -->
      <div id="gmPanel" class="hidden">
        <h2>Game Master Controls</h2>
        <div class="small">
          Leave this open. As squads finish, their bots will appear in the queue.<br>
          When everyone is done, hit START TOURNAMENT.
        </div>
        <button class="main" onclick="refreshBots()">Refresh Bots Now</button>
        <button class="main" id="startBtn" onclick="prepareTournament()">START TOURNAMENT</button>
        <div id="countdown"></div>
      </div>
    </div>

    <!-- Bots List (GM only visible; hidden for squads) -->
    <div id="bots">
      <h2>Squad Bots in Tournament</h2>
      <div class="small">All finished squads appear here with their stats.</div>
      <div id="botsList"></div>
    </div>

    <!-- Battle Log (GM focus; hidden for squads) -->
    <div id="logPanel">
      <h2>Tournament Log</h2>
      <div id="log"></div>
    </div>
  </div>

  <script>
    let isGameMaster = false;

    // Shared battle data (GM side)
    let bots = [];
    let battleRunning = false;
    let duelInterval = null;

    // Tournament state
    let currentRoundCompetitors = [];
    let nextRoundCompetitors = [];
    let roundPairs = [];
    let currentPairIndex = 0;
    let roundNumber = 1;
    let duelMatchNumber = 1;

    // Squad-side quiz data
    let buildingBot = null;
    let currentQuestionIndex = 0;
    let quizTimer = null;
    let timeLeft = 35;
    let selectedAnswer = null; // track selected card
    let upgradeStats = {
      attack: 0,
      health: 0,
      speed: 0,
      crit: 0,
      correctCount: 0
    };

    // ROLE SELECTION
    function selectRole(role) {
      isGameMaster = (role === "gm");

      document.getElementById("arena").classList.remove("hidden");
      document.getElementById("roleSelect").classList.add("hidden");

      document.body.classList.remove("mode-squad", "mode-gm");
      if (isGameMaster) {
        document.body.classList.add("mode-gm");
        document.getElementById("gmPanel").classList.remove("hidden");
        document.getElementById("squadPanel").classList.add("hidden");
        refreshBots();
        // auto-refresh queue while idle
        setInterval(() => {
          if (!battleRunning) refreshBots(false);
        }, 5000);
      } else {
        document.body.classList.add("mode-squad");
        document.getElementById("squadPanel").classList.remove("hidden");
        document.getElementById("gmPanel").classList.add("hidden");
      }
    }

    // LOG UTILS
    function log(message) {
      const logDiv = document.getElementById("log");
      if (!logDiv) return; // squads won't see log, but avoid errors
      const line = document.createElement("div");
      line.className = "logLine";
      line.textContent = message;
      logDiv.appendChild(line);
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    function randomBetween(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function getHealthColor(healthPercent) {
      if (healthPercent > 60) return "#22c55e";     // green
      if (healthPercent > 30) return "#facc15";     // yellow
      return "#ef4444";                             // red
    }

    // 20 LEADERSHIP QUESTIONS (multiple choice)
    const leadershipQuestions = [
      {
        id: "q1",
        topic: "Capitalism",
        text: "Capitalism, as described here, is best understood as:",
        correct: "b",
        attr: "attack",
        options: {
          a: "A neutral way to trade goods and services",
          b: "A system where a ruling class gains wealth by controlling resources and exploiting labor",
          c: "Any system where everyone has equal access to money",
          d: "A political strategy used only during elections"
        }
      },
      {
        id: "q2",
        topic: "Capitalism",
        text: "In this definition of capitalism, who owns and controls most resources?",
        correct: "c",
        attr: "health",
        options: {
          a: "All workers equally",
          b: "The government only",
          c: "The ruling class",
          d: "Community organizations"
        }
      },
      {
        id: "q3",
        topic: "Heterosexism",
        text: "Heterosexism is a system that gives privilege to:",
        correct: "a",
        attr: "speed",
        options: {
          a: "Heterosexual people at the expense of queer people",
          b: "Anyone who is married",
          c: "Only men, no matter who they love",
          d: "Single people over people in relationships"
        }
      },
      {
        id: "q4",
        topic: "Heterosexism",
        text: "Which is an example of heterosexism?",
        correct: "d",
        attr: "crit",
        options: {
          a: "Allowing everyone to marry regardless of gender",
          b: "Celebrating Pride month at school",
          c: "Making space for queer student clubs",
          d: "Assuming only straight relationships are normal and deserving of full rights"
        }
      },
      {
        id: "q5",
        topic: "Internalized racism",
        text: "Internalized racism happens when people of color:",
        correct: "b",
        attr: "health",
        options: {
          a: "Never talk about racism at all",
          b: "Absorb racist beliefs and begin to see themselves as inferior",
          c: "Organize against racism in their communities",
          d: "Only make friends with people of their same background"
        }
      },
      {
        id: "q6",
        topic: "Internalized racism",
        text: "Which is a sign of internalized racism from this definition?",
        correct: "c",
        attr: "attack",
        options: {
          a: "Calling out racist jokes in the group chat",
          b: "Pushing back on Eurocentric beauty standards",
          c: "Believing lighter skin and straighter hair are automatically better",
          d: "Reading books by authors of color"
        }
      },
      {
        id: "q7",
        topic: "Patriarchy",
        text: "Patriarchy is described as a system that:",
        correct: "a",
        attr: "attack",
        options: {
          a: "Privileges men and dominates women using strict gender roles",
          b: "Only affects people in romantic relationships",
          c: "Helps everyone express gender freely",
          d: "Exists only in the past, not today"
        }
      },
      {
        id: "q8",
        topic: "Patriarchy",
        text: "According to this definition, patriarchy is connected to:",
        correct: "d",
        attr: "speed",
        options: {
          a: "Only individual attitudes, not systems",
          b: "Sports and entertainment only",
          c: "Anything that is not about race or class",
          d: "White supremacy, capitalism, and the State as interlocking systems"
        }
      },
      {
        id: "q9",
        topic: "Power",
        text: "One definition of power given here is:",
        correct: "c",
        attr: "crit",
        options: {
          a: "Having the loudest voice in the room",
          b: "Always being physically stronger than others",
          c: "The ability to define reality and convince others it is true",
          d: "Being popular on social media"
        }
      },
      {
        id: "q10",
        topic: "Power",
        text: "Another definition says power includes ownership and control of:",
        correct: "b",
        attr: "health",
        options: {
          a: "School clubs",
          b: "Major resources of the state and decision-making about them",
          c: "Only small local businesses",
          d: "Any personal belongings someone has"
        }
      },
      {
        id: "q11",
        topic: "Racism",
        text: "According to the People's Institute, racism is:",
        correct: "a",
        attr: "attack",
        options: {
          a: "Race prejudice plus power",
          b: "Any conflict between two people of different races",
          c: "Only individual hateful comments",
          d: "The same thing as culture"
        }
      },
      {
        id: "q12",
        topic: "Reverse racism",
        text: "Why does this definition say ‚Äúreverse racism‚Äù is not real?",
        correct: "d",
        attr: "speed",
        options: {
          a: "Because people of color can never be angry at injustice",
          b: "Because white people never experience harm",
          c: "Because it only happens online",
          d: "Because racism requires systemic power, which white people already hold in a white supremacy system"
        }
      },
      {
        id: "q13",
        topic: "Social construction",
        text: "A social construction is mainly about:",
        correct: "b",
        attr: "crit",
        options: {
          a: "Random traits people happen to have",
          b: "Grouping people into categories to rank them for the benefit of a dominant group",
          c: "Building new houses in a neighborhood",
          d: "Any role someone chooses freely"
        }
      },
      {
        id: "q14",
        topic: "White privilege",
        text: "White privilege is described as:",
        correct: "c",
        attr: "health",
        options: {
          a: "Individual white people always having easy lives",
          b: "Something that only exists in the past",
          c: "An institutionally perpetuated system of preferential treatment for white people based on European ancestry",
          d: "Only about personal kindness between individuals"
        }
      },
      {
        id: "q15",
        topic: "White privilege",
        text: "In this framework, white privilege and racial oppression are:",
        correct: "b",
        attr: "attack",
        options: {
          a: "Totally separate issues",
          b: "Two sides of the same coin",
          c: "Not connected to class or gender",
          d: "Problems that only show up outside the U.S."
        }
      },
      {
        id: "q16",
        topic: "White supremacy",
        text: "White supremacy is defined here as a system that:",
        correct: "a",
        attr: "speed",
        options: {
          a: "Exploits and oppresses peoples and nations of color to maintain wealth, power, and privilege for white nations",
          b: "Is only about individual hateful attitudes",
          c: "Has no connection to history",
          d: "Helps all races equally"
        }
      },
      {
        id: "q17",
        topic: "Leadership & Responsibility",
        text: "For a young leader, understanding systems like capitalism and patriarchy matters because:",
        correct: "d",
        attr: "crit",
        options: {
          a: "They are just vocabulary words for tests",
          b: "It guarantees they will get rich",
          c: "It lets them avoid any responsibility for change",
          d: "It helps them see who has power, who is harmed, and where they can act for justice"
        }
      },
      {
        id: "q18",
        topic: "Leadership & Community",
        text: "A leader challenging internalized racism in their community might:",
        correct: "c",
        attr: "health",
        options: {
          a: "Encourage people to hide their culture",
          b: "Tell people never to talk about race",
          c: "Celebrate Black and Brown features, stories, and knowledge as valuable",
          d: "Only listen to experts from Europe"
        }
      },
      {
        id: "q19",
        topic: "Power & Access",
        text: "Which example best matches the definition of power as 'access to those who control resources of the state'?",
        correct: "b",
        attr: "speed",
        options: {
          a: "Getting a lot of likes on a post",
          b: "Being able to speak directly with school board members who decide budgets",
          c: "Being the tallest player on the team",
          d: "Owning a gaming console at home"
        }
      },
      {
        id: "q20",
        topic: "Critical Leadership",
        text: "When someone says, ‚ÄúMy experience is the only reality that matters,‚Äù which power definition helps you challenge that?",
        correct: "a",
        attr: "crit",
        options: {
          a: "Power as the ability to define reality and get others to accept it",
          b: "Power as being the funniest person in the group chat",
          c: "Power as never making mistakes",
          d: "Power as always agreeing with authority"
        }
      }
    ];

    // We'll shuffle once per squad quiz so sections feel randomized
    function shuffledQuestions() {
      const arr = [...leadershipQuestions];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    let questions = []; // will be set per squad run

    // SQUAD QUIZ FLOW
    function startQuiz() {
      if (battleRunning) return;

      const nameInput = document.getElementById("botName");
      const emojiSelect = document.getElementById("botEmoji");
      const name = nameInput.value.trim();
      const emoji = emojiSelect.value;

      if (!name) {
        alert("Enter your squad bot name first.");
        return;
      }

      buildingBot = { name, emoji };

      upgradeStats = { attack: 0, health: 0, speed: 0, crit: 0, correctCount: 0 };
      currentQuestionIndex = 0;
      questions = shuffledQuestions(); // randomize order

      document.getElementById("quizSummary").textContent = "";
      document.getElementById("quizContainer").style.display = "block";
      document.getElementById("startQuizBtn").disabled = true;

      log(`${emoji} Squad "${name}" started the leadership quiz to power up their bot.`);
      showQuestion(currentQuestionIndex);
    }

    function showQuestion(index) {
      if (index >= questions.length) {
        finalizeSquadBot();
        return;
      }

      const q = questions[index];
      const box = document.getElementById("questionBox");
      selectedAnswer = null; // reset selection

      box.innerHTML = `
        <div class="q-text">${q.text}</div>
        ${Object.keys(q.options)
          .map(letter => `
            <div class="answerOption" data-value="${letter}" onclick="selectAnswer('${letter}')">
              <span class="answerLetter">${letter.toUpperCase()}</span>
              <span>${q.options[letter]}</span>
            </div>
          `)
          .join("")}
      `;

      startQuestionTimer();
    }

    function selectAnswer(letter) {
      selectedAnswer = letter;
      const options = document.querySelectorAll(".answerOption");
      options.forEach(opt => {
        if (opt.getAttribute("data-value") === letter) {
          opt.classList.add("selected");
        } else {
          opt.classList.remove("selected");
        }
      });
    }

    function startQuestionTimer() {
      if (quizTimer) {
        clearInterval(quizTimer);
      }
      timeLeft = 35;
      updateTimerDisplay();

      quizTimer = setInterval(() => {
        timeLeft--;
        updateTimerDisplay();

        if (timeLeft <= 0) {
          clearInterval(quizTimer);
          lockCurrentQuestionAsWrong();
          goToNextQuestion();
        }
      }, 1000);
    }

    function updateTimerDisplay() {
      const timerEl = document.getElementById("quizTimer");
      timerEl.textContent = `‚è≥ ${timeLeft}s`;
    }

    function submitAnswer() {
      if (!buildingBot) return;
      if (quizTimer) {
        clearInterval(quizTimer);
      }

      const q = questions[currentQuestionIndex];

      if (selectedAnswer && selectedAnswer === q.correct) {
        upgradeStats[q.attr]++;
        upgradeStats.correctCount++;
      }

      goToNextQuestion();
    }

    function lockCurrentQuestionAsWrong() {
      selectedAnswer = null;
    }

    function goToNextQuestion() {
      currentQuestionIndex++;
      showQuestion(currentQuestionIndex);
    }

    async function finalizeSquadBot() {
      if (!buildingBot) return;

      let maxHealth = 100 + upgradeStats.health * 15;
      let attackMin = 5 + upgradeStats.attack;
      let attackMax = 12 + upgradeStats.attack * 3;
      let speed = 5 + upgradeStats.speed * 2;
      let critChance = 5 + upgradeStats.crit * 6;

      const name = buildingBot.name;
      const emoji = buildingBot.emoji;

      const botPayload = {
        name,
        emoji,
        maxHealth,
        attackMin,
        attackMax,
        speed,
        crit: critChance
      };

      try {
        await fetch("/api/bots", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(botPayload)
        });
      } catch (err) {
        console.error("Error sending bot:", err);
        alert("Error sending bot to arena. Tell the Game Master.");
      }

      const summary = document.getElementById("quizSummary");
      summary.innerHTML = `
        ‚úÖ Squad locked in <strong>${emoji} ${name}</strong><br>
        Correct answers: <strong>${upgradeStats.correctCount}/20</strong><br>
        Upgrades ‚Üí Attack: +${upgradeStats.attack}, Health: +${upgradeStats.health}, Speed: +${upgradeStats.speed}, Crit: +${upgradeStats.crit}<br><br>
        üî• Your bot has been sent to the tournament bracket. You can close this tab or wait for the stream.
      `;

      log(`‚úÖ ${emoji} Squad "${name}" finished the quiz: ${upgradeStats.correctCount}/20 correct. Their bot enters the bracket!`);

      buildingBot = null;
      document.getElementById("startQuizBtn").disabled = false;
      document.getElementById("quizContainer").style.display = "none";
      document.getElementById("botName").value = "";
    }

    // --- BATTLE META: roles & underdog logic ---

    function classifyBotsForBattle() {
      bots.forEach(b => {
        const avgAtk = (b.attackMin + b.attackMax) / 2;

        // rough archetype based on stats
        let style = "Trickster";
        if (b.maxHealth >= 160) {
          style = "Tank";
        } else if (b.crit >= 30) {
          style = "Assassin";
        } else if (avgAtk >= 15) {
          style = "Bruiser";
        }

        b.style = style;

        // overall "power score" for underdog detection
        b.powerScore =
          avgAtk * 1.2 +
          (b.maxHealth / 10) +
          b.speed * 1.3 +
          b.crit * 0.5;
      });
    }

    const typeAdvantage = {
      Tank:     { Tank: 1.0, Bruiser: 0.9, Assassin: 1.15, Trickster: 1.0 },
      Bruiser:  { Tank: 1.1, Bruiser: 1.0, Assassin: 0.9, Trickster: 1.0 },
      Assassin: { Tank: 1.25, Bruiser: 1.05, Assassin: 1.0, Trickster: 0.9 },
      Trickster:{ Tank: 0.95, Bruiser: 1.1, Assassin: 1.05, Trickster: 1.0 }
    };

    function computeDamage(attacker, target) {
      let base = randomBetween(attacker.attackMin, attacker.attackMax);

      // role matchup
      let matchup = 1.0;
      const aType = attacker.style || "Trickster";
      const tType = target.style || "Trickster";
      if (typeAdvantage[aType] && typeAdvantage[aType][tType]) {
        matchup = typeAdvantage[aType][tType];
      }
      base *= matchup;

      // base crit chance
      let effectiveCrit = attacker.crit;

      // comeback buff if attacker is low HP
      const hpRatio = attacker.health / attacker.maxHealth;
      if (hpRatio < 0.3) {
        effectiveCrit += 10;  // clutch chance
        base *= 1.05;
      }

      // underdog buff: if attacker is clearly weaker than target
      const attackerScore = attacker.powerScore || 0;
      const targetScore = target.powerScore || 0;
      let isUnderdogHit = false;
      if (attackerScore + 6 < targetScore) {
        isUnderdogHit = true;
        effectiveCrit += 12;
        base *= 1.18;
      }

      // crit roll
      let critHit = false;
      if (Math.random() * 100 < effectiveCrit) {
        critHit = true;
        base *= 1.8;
      }

      const finalDamage = Math.max(1, Math.round(base));
      return { damage: finalDamage, critHit, matchup, isUnderdogHit };
    }

    // GM: FETCH & RENDER BOTS
    async function refreshBots(showLog = true) {
      try {
        const res = await fetch("/api/bots");
        const data = await res.json();
        bots = data || [];
        // reset any missing health display
        bots.forEach(b => {
          if (b.health == null) b.health = b.maxHealth;
        });
        classifyBotsForBattle();
        renderAllBots();
        if (showLog) {
          log(`üîÑ Refreshed bots. Total squads: ${bots.length}`);
        }
      } catch (err) {
        console.error("Error fetching bots:", err);
        if (showLog) log("‚ùå Error fetching bots.");
      }
    }

    function renderAllBots() {
      const list = document.getElementById("botsList");
      list.innerHTML = "";

      bots.forEach(bot => {
        const botDiv = document.createElement("div");
        botDiv.className = "bot";
        botDiv.id = "bot-" + bot.id;

        botDiv.innerHTML = `
          <div class="botEmoji">${bot.emoji}</div>
          <div class="botInfo">
            <div class="botName">${bot.name}</div>
            <div class="health">
              <div class="bar" id="bar-${bot.id}"></div>
            </div>
            <div class="stats">
              HP: <span id="hp-${bot.id}">${bot.health}</span> |
              ATK: ${bot.attackMin}-${bot.attackMax} |
              SPD: ${bot.speed} |
              CRIT: ${bot.crit}% |
              ROLE: ${bot.style || "‚Äî"}
            </div>
          </div>
          <button class="tauntBtn" onclick="taunt(${bot.id})">Taunt</button>
        `;

        list.appendChild(botDiv);
        updateBotUI(bot);
      });
    }

    function updateBotUI(bot) {
      const percent = (bot.health / bot.maxHealth) * 100;
      const bar = document.getElementById("bar-" + bot.id);
      const hpText = document.getElementById("hp-" + bot.id);

      if (!bar || !hpText) return;

      bar.style.width = percent + "%";
      bar.style.backgroundColor = getHealthColor(percent);
      hpText.textContent = Math.max(0, Math.round(bot.health));
    }

    function taunt(id) {
      const bot = bots.find(b => b.id === id);
      if (!bot) return;

      const taunts = [
        "This is free XP üíÄ",
        "Easy clap üòÇ",
        "Y'all sure about this?",
        "Light work üí™",
        "Don't lag now üëÄ",
        "I'm HIM.",
        "Say goodbye üòà"
      ];
      const botDiv = document.getElementById("bot-" + id);
      if (!botDiv) return;

      const bubble = document.createElement("div");
      bubble.className = "tauntBubble";
      bubble.textContent = taunts[Math.floor(Math.random() * taunts.length)];
      botDiv.appendChild(bubble);

      setTimeout(() => {
        bubble.remove();
      }, 1000);

      log(`${bot.emoji} ${bot.name} taunts the arena.`);
    }

    // -------- TOURNAMENT BRACKET LOGIC (1v1, rounds) --------

    function prepareTournament() {
      if (!isGameMaster) {
        alert("Only the Game Master can start the tournament.");
        return;
      }
      if (battleRunning) return;
      if (bots.length < 2) {
        alert("Need at least 2 squad bots to run a bracket.");
        return;
      }

      battleRunning = true;

      // Reset health for fair tournament
      bots.forEach(b => {
        b.health = b.maxHealth;
      });
      classifyBotsForBattle();
      renderAllBots();

      // Random seeding
      currentRoundCompetitors = [...bots].sort(() => Math.random() - 0.5);
      nextRoundCompetitors = [];
      roundNumber = 1;
      duelMatchNumber = 1;

      log("üèÅ Tournament seeded. Bots are being shuffled into a bracket...");
      makeRoundPairs();

      let count = 3;
      const countdownDiv = document.getElementById("countdown");
      countdownDiv.textContent = "Tournament starts in: " + count;

      const countdownInterval = setInterval(() => {
        count--;
        if (count > 0) {
          countdownDiv.textContent = "Tournament starts in: " + count;
        } else {
          clearInterval(countdownInterval);
          countdownDiv.textContent = "Round 1 ‚Äì Fight!";
          log(`üî• ROUND ${roundNumber} begins! Every match is 1v1 ‚Äì winner moves on.`);
          startNextDuel();
        }
      }, 900);
    }

    function makeRoundPairs() {
      roundPairs = [];
      nextRoundCompetitors = [];
      currentPairIndex = 0;

      // if odd, last bot gets a bye
      if (currentRoundCompetitors.length % 2 === 1) {
        const byeBot = currentRoundCompetitors.pop();
        nextRoundCompetitors.push(byeBot);
        log(`üé´ BYE: ${byeBot.emoji} ${byeBot.name} (${byeBot.style}) advances automatically to the next round.`);
      }

      for (let i = 0; i < currentRoundCompetitors.length; i += 2) {
        const a = currentRoundCompetitors[i];
        const b = currentRoundCompetitors[i + 1];
        roundPairs.push([a, b]);
      }
    }

    function startNextDuel() {
      // If we finished all pairs in this round, move to next round
      if (currentPairIndex >= roundPairs.length) {
        // If only one bot remains overall, we have a champion
        if (nextRoundCompetitors.length === 1) {
          const champ = nextRoundCompetitors[0];
          const countdownDiv = document.getElementById("countdown");
          countdownDiv.textContent = `üèÜ CHAMPION: ${champ.emoji} ${champ.name}`;
          log(`üèÜ TOURNAMENT CHAMPION: ${champ.emoji} ${champ.name} (${champ.style}) survives every round!`);
          battleRunning = false;
          return;
        }

        // Otherwise, start the next round with winners
        currentRoundCompetitors = [...nextRoundCompetitors];
        makeRoundPairs();
        roundNumber++;
        duelMatchNumber = 1;
        log(`üî• ROUND ${roundNumber} begins with ${currentRoundCompetitors.length + nextRoundCompetitors.length} bots in play.`);
      }

      const [a, b] = roundPairs[currentPairIndex];
      log(`‚öîÔ∏è ROUND ${roundNumber}, MATCH ${duelMatchNumber}: ${a.emoji} ${a.name} (${a.style}) vs ${b.emoji} ${b.name} (${b.style}). Place your bets.`);
      currentPairIndex++;
      duelMatchNumber++;

      startDuelLoop(a, b);
    }

    function startDuelLoop(botA, botB) {
      if (duelInterval) clearInterval(duelInterval);

      // Ensure full health entering match (in case)
      botA.health = botA.health ?? botA.maxHealth;
      botB.health = botB.health ?? botB.maxHealth;
      updateBotUI(botA);
      updateBotUI(botB);

      duelInterval = setInterval(() => {
        const alive = [botA, botB].filter(b => b.health > 0);
        if (alive.length <= 1) {
          clearInterval(duelInterval);
          const winner = alive[0];
          const loser = (winner && winner.id === botA.id) ? botB : botA;

          if (winner) {
            log(`üí• ${winner.emoji} ${winner.name} (${winner.style}) ELIMINATES ${loser.emoji} ${loser.name} and moves on!`);
            nextRoundCompetitors.push(winner);
          } else {
            log("Both bots knocked each other out ‚Äì no one advances from this match.");
          }
          startNextDuel();
          return;
        }

        // decide attacker based on speed
        const attacker = pickWeightedAttacker([botA, botB]);
        const target = attacker.id === botA.id ? botB : botA;

        const { damage, critHit, matchup, isUnderdogHit } = computeDamage(attacker, target);
        target.health = Math.max(0, target.health - damage);

        animateAttack(attacker, target);
        updateBotUI(target);

        const hpLeft = Math.round(target.health);
        const lowHp = hpLeft > 0 && target.health / target.maxHealth < 0.25;

        let matchupTag = "";
        if (matchup > 1.15) matchupTag = " (counter hit!)";
        else if (matchup < 0.9) matchupTag = " (resisted)";

        if (target.health <= 0) {
          if (critHit && isUnderdogHit) {
            log(`üí£ UPSET KO! ${attacker.emoji} ${attacker.name} (${attacker.style}) deletes favorite ${target.emoji} ${target.name} with ${damage} damage${matchupTag}. Underdog moves on!`);
          } else if (critHit) {
            log(`üí• CRIT KO! ${attacker.emoji} ${attacker.name} (${attacker.style}) finishes ${target.emoji} ${target.name} with ${damage} damage${matchupTag}.`);
          } else {
            log(`üí• ${attacker.emoji} ${attacker.name} (${attacker.style}) knocks out ${target.emoji} ${target.name} for ${damage} damage${matchupTag}.`);
          }
        } else {
          if (critHit && isUnderdogHit) {
            log(`‚ö° UPSET STRIKE! ${attacker.emoji} ${attacker.name} (${attacker.style}) stuns ${target.emoji} ${target.name} for ${damage} damage${matchupTag}. ${hpLeft} HP left ‚Äì crowd screaming.`);
          } else if (critHit) {
            log(`‚ö° CRIT! ${attacker.emoji} ${attacker.name} (${attacker.style}) blasts ${target.emoji} ${target.name} for ${damage} damage${matchupTag}. (${hpLeft} HP left)`);
          } else if (lowHp) {
            log(`üò± ${attacker.emoji} ${attacker.name} (${attacker.style}) leaves ${target.emoji} ${target.name} hanging on with only ${hpLeft} HP${matchupTag}. One more tap might end it.`);
          } else {
            log(`ü•ä ${attacker.emoji} ${attacker.name} (${attacker.style}) tags ${target.emoji} ${target.name} for ${damage} damage${matchupTag}. (${hpLeft} HP left)`);
          }
        }
      }, 1100);
    }

    function pickWeightedAttacker(alive) {
      const totalSpeed = alive.reduce((sum, b) => sum + b.speed, 0);
      let roll = Math.random() * totalSpeed;
      for (const b of alive) {
        if (roll < b.speed) return b;
        roll -= b.speed;
      }
      return alive[0];
    }

    function animateAttack(attacker, target) {
      const attackerDiv = document.getElementById("bot-" + attacker.id);
      const targetDiv = document.getElementById("bot-" + target.id);

      if (attackerDiv) {
        attackerDiv.classList.add("attacking");
        setTimeout(() => attackerDiv.classList.remove("attacking"), 250);
      }

      if (targetDiv) {
        targetDiv.classList.add("hit");
        setTimeout(() => targetDiv.classList.remove("hit"), 250);
      }
    }
  </script>

</body>
</html>
